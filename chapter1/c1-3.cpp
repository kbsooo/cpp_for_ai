// 1. std::thread, std::mutex, std::atomic의 역할과 차이점을 각각 설명해 보세요.
/*
thread:
역할: 프로그램 내에서 독립적으로 실행될 수 있는 별도의 실행 흐름(또는 작업 단위)을 생성하고 관리합니다. 이를 통해 여러 작업을 병렬적 또는 동시적으로 처리하여 프로그램의 응답성이나 처리량을 향상시킬 수 있습니다.
예시: 하나의 스레드가 사용자 인터페이스를 처리하는 동안 다른 스레드는 백그라운드에서 파일을 다운로드하거나 복잡한 계산을 수행할 수 있습니다.

mutex:
역할: 여러 스레드가 공유 자원(예: 변수, 데이터 구조, 특정 코드 섹션)에 동시에 접근하여 발생하는 문제를 막기 위한 동기화 기본 요소입니다. 한 번에 하나의 스레드만 뮤텍스를 소유(lock)하고 해당 공유 자원에 접근할 수 있도록 하여, 데이터 경쟁(race condition)을 방지하고 공유 자원의 일관성을 유지합니다.
동작 방식: 스레드는 공유 자원에 접근하기 전에 뮤텍스에 대해 lock()을 시도하고, 사용 후에는 unlock()을 호출하여 다른 스레드가 접근할 수 있도록 합니다. (std::lock_guard나 std::unique_lock 등을 사용하면 자동 잠금 해제가 가능합니다.)
차이점: 코드의 특정 구간(임계 영역, critical section)을 보호하며, 이 구간은 한 번에 하나의 스레드만 실행할 수 있도록 순서를 강제합니다.

atomic:
역할: 정수형이나 포인터 같은 특정 타입의 변수에 대한 연산(예: 증가, 감소, 읽기, 쓰기, 비교-교환)이 원자적으로(더 이상 쪼갤 수 없는 단일 작업으로) 실행되도록 보장합니다. 즉, 연산 도중에 다른 스레드가 끼어들 수 없어 데이터가 깨지는 것을 방지합니다.
동작 방식: CPU 수준에서 특별한 명령어를 사용하여 구현되며, 명시적인 락(lock) 없이도 스레드 간 안전한 데이터 공유를 가능하게 합니다. 이는 락을 사용하는 뮤텍스보다 오버헤드가 적을 수 있습니다.
차이점: 뮤텍스가 코드 블록을 보호하는 반면, std::atomic은 개별 변수에 대한 특정 연산의 원자성을 보장합니다. 뮤텍스는 락(lock)을 기반으로 동기화하지만, std::atomic 연산은 종종 락-프리(lock-free)로 구현될 수 있습니다 (항상 그런 것은 아님).
*/

// 2. 다음 코드는 race condition이 발생합니다. std::mutex 또는 std::atomic을 사용하여 이를 해결해 보세요.
/*
#include <thread>
int counter = 0;
void foo() { for(int i=0;i<1000;i++) ++counter; }
int main() {
    std::thread t1(foo);
    std::thread t2(foo);
    t1.join();
    t2.join();
    // 원하는 값: 2000
    return 0;
}
*/

#include <thread>
#include <iostream>
#include <atomic>
using namespace std;

atomic<int> atomicCounter{0};

void foo() {
    for (int i = 0; i < 1000; i++) {
        atomicCounter.fetch_add(1, memory_order_relaxed);
    }
}

int main() {
    std::thread t1(foo);
    std::thread t2(foo);
    t1.join();
    t2.join();

    cout << atomicCounter.load() << endl;
    // 원하는 값: 2000
    return 0;
}

// 3. std::thread의 join()과 detach()의 차이점을 설명하고, 각각의 사용 예를 들어 보세요.
/*
std::thread 객체가 생성되어 새로운 스레드가 실행을 시작하면, 생성된 스레드는 생성한 스레드와 독립적으로 실행됩니다. 이 스레드 객체가 소멸되기 전에는 반드시 join() 또는 detach() 중 하나를 호출해야 합니다. 그렇지 않으면 프로그램이 비정상 종료될 수 있습니다 (std::terminate 호출).

join():
설명: join()을 호출한 스레드(보통 부모 스레드 또는 스레드를 생성한 스레드)는 해당 std::thread 객체가 나타내는 스레드(자식 스레드)의 실행이 완료될 때까지 대기합니다. 자식 스레드가 종료되면 join() 호출은 반환되고, 자식 스레드가 사용했던 모든 자원은 정리됩니다. join()이 반환된 후에는 해당 std::thread 객체는 더 이상 실행 중인 스레드를 나타내지 않게 됩니다(joinable하지 않음).
사용 예:
자식 스레드가 어떤 계산을 수행하고 그 결과가 부모 스레드에게 필요할 때.
여러 스레드를 실행시킨 후, 모든 스레드가 작업을 마쳐야 다음 단계로 진행할 수 있을 때.
프로그램이 종료되기 전에 모든 스셔브 작업이 완료되도록 보장하고 싶을 때.

detach():
설명: detach()를 호출하면 해당 std::thread 객체와 실제 실행 중인 스레드 간의 연결이 끊어집니다. 스레드는 백그라운드에서 계속 독립적으로 실행되며, std::thread 객체는 더 이상 그 스레드를 나타내지 않게 됩니다(joinable하지 않음). 이렇게 분리된 스레드는 자신이 종료될 때 스스로 자원을 정리해야 합니다. 프로그래머는 분리된 스레드가 사용하는 데이터(예: 포인터나 참조)가 스레드 실행 중에 유효하도록 보장해야 할 책임이 있습니다.
사용 예:
스레드가 실행하는 작업이 오래 걸리고, 부모 스레드가 그 결과를 기다릴 필요 없이 다른 작업을 계속해야 하는 경우 (예: 백그라운드 로깅, 감시 작업, 독립적인 서비스 제공).
"실행하고 잊어버리는(fire-and-forget)" 스타일의 작업.
*/