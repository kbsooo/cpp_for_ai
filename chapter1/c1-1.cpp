/*
연습 문제

1. RAII와 스마트 포인터가 메모리 안정성에 어떻게 기여하는지?
RAII (Resource Acquisition is Initialization) 기법은 객체가 생성될 때 (초기화 시) 자원을 획득하고, 객체가 소멸될 때 자원을 자동으로 해제하도록 함
스마트 포인터 (std::unique_ptr, std::shared_ptr)은 RAII 원칙을 따르는 대표적 예시
1. 자동 메모리 해제: 스마트 포인터는 동적으로 할당된 메모리를 가리키며, 자신이 소멸될 때 자신이 가리키는 메모리도 자동으로 해제. 이는 delete를 직접 호출하는 것을 잊어서 발생하는 메모리 누수를 방지
2. 예외 안전성: 함수 실행중 예외가 발생하면, 해당 함수 내에서 생성된 지역 객체들의 소멸자가 호출됨

2. std::unique_ptr 와 std::shared_ptr의 차이점을 요약하고, 각자가 적합한 상황은?
독점적 소유권 vs 공유 소유권
unique_ptr: 특정 시점에 오직 하나의 unique_ptr만이 해당 객체를 소유 가능
shared_ptr: 여러 인스턴스가 동일한 객체를 가리키고 소유권을 공유할 수 있음

복사 vs 이동
unique_ptr: 복사 생성자 및 복사 대입 연산자가 삭제되어 복사 불가능, std::move 를 통한 이동만 가능
shared_ptr: 복사 가능, 복사 될 때마다 내부의 참조 카운트가 증가

메모리 해제 시점
unique_ptr: 소멸되거나 reset()될 때, 또는 다른 unique_ptr로 소유권이 이동될 때 객체가 소멸
shared_ptr: 마지막 shared_ptr이 소멸되거나 reset()되어 참조 카운트가 0이 될 때 소멸

오버헤드
unique_ptr: shared_ptr에 비해 오버헤드가 거의 없음
shared_ptr: 참조 카운트를 위한 추가 공간과 원자적 연산으로 인한 약간의 성능 오버헤드가 있음


std::unique_ptr<T>
- 명확한 단일 소유권: 객체의 생명주기가 명확하게 하나의 스코프나 객체에 의해 관리될 때
- 팩토리 함수 반환 타입: 팩토리 함수에서 생성된 객체의 소유권을 안전하게 이전할 때
- pimpl idiom: 구현 세부 사항을 숨기고 컴파일 의존성을 줄일때
- STL 컨테이너의 원소: 다형적 객체를 저장할 때
- 성능이 중요하고 공유 소유권이 필요 없을 때

std:shared_ptr<T>
- 공유 소유권 필요: 여러 객체가 동일한 자원에 대한 소유권을 공유해야 하고, 그 자원의 생명주기가 가장 마지막 참조자가 사라질 때까지 유지되어야 할 때
- 자료 구조에서의 공유: 그래프나 리스트 등에서 노드들이 서로를 참조하거나, 여러 곳에서 동일한 데이터를 참조할 때
- 비동기 작업 및 콜백: 객체가 비동기 작업이 완료될 때까지 살아있어야 하는 경우, 콜백 함수나 작업 객체가 shared_ptr을 통해 객체의 생명 주기를 연장 가능
- 복사해야 하는 객체 포인터: 객체에 대한 포인터를 여러 곳에 복사해서 전달해야 하고, 각 복사본이 원본 객체의 생명주기에 영향을 미치는 경우
*/

// 3. 다음 코드에서 메모리 누수가 발생하는 문제를 찾아 수정해 보세요. (힌트: 스마트 포인터를 사용하세요.
void leak()
{
  int *p = new int(42);
  // ... p를 사용
  // 누락된 delete로 메모리 누수 발생
}

#include <iostream>
#include <memory>

void no_leak()
{
  std::unique_ptr<int> p = std::make_unique<int>(42);
  // ... p 사용
}

int main()
{
  no_leak();
  // 누수 X
  return 0;
}